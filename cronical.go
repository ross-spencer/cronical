package main

import (
	"flag"
	"fmt"
	"os"
	"os/exec"
)

var (
	vers bool
	help bool
)

const (
	success = iota
	failure
)

func init() {
	flag.BoolVar(&help, "h", false, "Print usage instructions for cronical (shorthand)")
	flag.BoolVar(&help, "help", false, "Print usage instructions for cronical")
	flag.BoolVar(&vers, "v", false, "Return cronical version (shorthand)")
	flag.BoolVar(&vers, "version", false, "Return cronical version")
}

func runCron() {
	out, err := exec.Command("crontab", "-l").Output()
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error: %s (ensure there are crontab entries)\n", err)
		os.Exit(failure)
	}
	cronlist, errlist := ParseCrontab(string(out))
	if len(errlist) != 0 {
		fmt.Println("There are errors...")
	}
	for _, c := range cronlist {
		fmt.Println(c)
	}
}

// Possible options for resilience as an exe:
//
// 1. No args.
// 2. Exit on error.
// 3. Default: Output calendar for valid entries.
//
func main() {
	flag.Parse()
	if vers {
		fmt.Fprintf(os.Stderr, "%s \n", version())
		os.Exit(success)
	}
	if help {
		fmt.Fprintln(os.Stderr, "Usage:  cronical")
		fmt.Fprintln(os.Stderr, "")
		fmt.Fprintln(os.Stderr, "Output: [FILE] calendar.cal")
		fmt.Fprintf(os.Stderr, "Output: [STRING] '%s ...'\n\n", version())
		// Also print the usage instructions generated by flag.
		flag.Usage()
		os.Exit(success)
	}
	runCron()
}
